export const portalDictionary = {
  general: [{
    subtitle: 'Введение',
    text: ['Solid - это быстрая декларативная библиотека JavaScript для создания пользовательских интерфейсов в веб-приложениях. Он похож на React.js, Vue или Angular. Он не использует виртуальную модель DOM. Подобно Svelte, он поставляется с компилятором, который компилирует шаблоны до реальных узлов DOM и оборачивает обновления в мелкозернистые реакции.', 'В результате получается сильно оптимизированное, сверхлегкое и безумно быстрое веб-приложение. Он чрезвычайно эффективен, близок к оптимально написанному от руки простому JavaScript. Благодаря подходу, основанному на компиляторе, Solid может легко поддерживать хорошо известные возможности React, такие как Context, Suspense, SSR, асинхронный рендеринг и другие, без ущерба для размера конечного приложения (компилятор включает только то, что вы используете) или производительности.', 'Solid следует той же философии, что и React, с однонаправленным потоком данных, разделением чтения / записи и неизменяемыми интерфейсами. Просто у него совершенно другая реализация, в которой не используется виртуальный DOM.'],
  }],
  reactivity: [
    {
      subtitle: 'Signals',
      text: ['Сигналы являются краеугольным камнем реактивности Solid. Они содержат значения, которые меняются со временем; когда вы меняете значение Сигнала, он автоматически обновляет все, что его использует.', 'Аргумент, переданный createSignal, — это начальное значение, а возвращаемое значение — это кортеж (tuple) с двумя функциями: геттером и сеттером. С помощью деструктуризации мы можем называть эти функции как угодно.', 'В Solid нужно явным образом вызвать геттер для выявления момента чтения значения, что позволяет отслеживать изменения значений.']
    },
    {
      subtitle: 'Effects',
      text: ['Эффект автоматически подписывается на любой Сигнал, который считывается во время выполнения функции, эффект запускается при инициализации перезапускается при изменении любого из них.', 'Каждый раз когда сигнал изменяется - функция обертка обнаруживает это и подписывается на него, поэтому сигналы используют геттеры', 'C помощью сигналов и эффектов создается большая часть поведения приложения.']
    },
    {
      subtitle: 'Memo',
      text: ['Мы можем использовать createMemo для вычисления функции и сохранения результата до тех пор, пока не изменятся её зависимости. Это отлично подходит для кэширования вычислений эффектов, которые имеют другие зависимости, и упрощения некоторых дорогостоящих операций, таких как создание узла DOM.']
    },
  ],
  'show & switch': [
    {
      subtitle: 'Show',
      text: ['Show отвечает за условный рендеринг используя условие when и fallback', 'Пропс fallback выполняет функцию else и будет показан в том случае если условие, которое мы передали в when вернёт falsy значение.']
    },
    {
      subtitle: 'Switch and Match',
      text: ['Для случаев, когда в нашей логике есть больше чем два ветвлений мы можем использовать Switch и Match компоненты.', 'Компонент Switch будет читать условия сверху вниз, и остановится на первом правдивом. Если ни одно из условий не будет выполнено мы зарендерим компонент из fallback.']
    }
  ],
  'for & index': [
    {
      subtitle: 'For',
      text: ['При переборе он автоматически создает ключи по ссылки, что позволяет оптимизировать его при обновлении данных или перемещении строк, избегая пересоздания списка целиком.']
    },
    {
      subtitle: 'Index',
      text: ['Если у вас есть массив строк и , а массив короткий или вы никогда не вставляете и не удаляете элементы в середине массива, используйте <Index>.', 'Разница заключается в том, как обновляется DOM при изменении элементов массива. <For> всегда проверяет, был ли элемент в массиве перед изменением, и перемещает узлы DOM, чтобы отразить изменение положения элемента.', '<Index> этого не делает — это намного проще, он просто сравнивает старые и новые элементы по каждому индексу, и если они различаются, он вызывает сигнал item()']
    }
  ],
  dynamic: [
    {
      subtitle: 'Dynamic render',
      text: ['Компонент полезен когда нам нужно определить вид компонента для рендера с помощью данных. Он позволяет передавать либо строку для нативного элемента, либо функцию компонента, и он будет рендерить её вместе с предоставленными (props).'],
    },
    {
      subtitle: 'Hook onMount',
      text: ['createEffect который называется onMount который никогда не будет перезапущен. Это простой Эффект, применяя который, вы можете быть уверены, что он будет запущен единожды при начальной отрисовке.', 'Жизненные циклы выполняются только в браузере, поэтому размещенный в onMount код не запускается на сервере во время SSR.']
    },
    {
      subtitle: 'Hook onCleanUp',
      text: ['Поскольку все в дереве рендеринга Solid живет внутри Эффекта и может быть вложенным, разработчики выделили метод onCleanup для удобства использования при очистке. Вы можете вызвать его в любом скоупе, и он будет запущен, когда этот скоуп будет изменен или удален.', 'Его можно использовать в компонентах, Эффектах, кастомных директивах — практически в любом синхронном реактивном коде.']
    }
  ],
  'error boundary': [
    {
      subtitle: 'Error processing',
      text: ['Границы ошибок - это компоненты, которые перехватывают ошибки JavaScript в любом месте своего дочернего дерева компонентов, регистрируют эти ошибки и отображают резервный пользовательский интерфейс вместо дерева компонентов, в котором произошел сбой.'],
    }
  ],
  portal: [
    {
      subtitle: 'Contol flow',
      text: ['Компонент , дочерний контент которого будет вставлен в выбранном вами месте. По умолчанию его элементы будут отображаться в встроенным в document.body.'],
    }
  ],
  actions: [
    {
      subtitle: "Events",
      text: ['Cобытия не включаются в реактивные обертки. Они вызываются и им не нужна реактивность они прикрепляются (bound) только единожды.', 'Стандартные UI события (которые всплывают и композируются (composed)) автоматически делегируются документу. Для улучшения перформанса при делегации Solid поддерживает синтаксис в виде массива, чтобы вызывать слушателя без создания дополнительных замыканий']
    }
  ],
  styles: [
    {
      subtitle: 'Class',
      text: ['Атрибут style в Solid принимает в себя строки и объекты. Однако объект отличается от Element.prototype.style и вместо этого мы используем его как обертку для вызова style.setProperty.', 'Это значит, что ключи принимают форму через-дефис (dash-case), например backgroundColor становится background-color. Такая форма позволяет нам использовать CSS переменные и сигналы'],
    },
    {
      subtitle: 'ClassList',
      text: ['В Solid существует classList атрибут, который принимает объект, в котором ключ это имя класса, а его значение это boolean. Когда значение равно true, класс будет добавлен, когда значение false класс будет удален.']
    }
  ],
  refs: [
    {
      subtitle: 'DOM elements',
      text: ['Если вы хотите получить ссылку на элемент, то для этого в Solid есть атрибут ref. Мы можем представить себе ref как определение переменной. Они создаются во время создания перед тем как мы прикрепляем их к нашему документу.', 'Также мы можем использовать ref в виде функции-коллбека (callback function). Это удобно для того, чтобы инкапсулировать (encapsulate) логику, особенно когда нам не нужно ждать когда элемент будет прикреплен.', 'Также мы можем передавать ref во вложенный компонент, через props.ref'],
    }
  ],
  spread: [
    {
      subtitle: 'Spread props',
      text: ['Иногда наши компоненты и элементы получают несколько атрибутов и в таком случае имеет смысл оформить их в виде объекта, а не передавать по одному. Это довольно частый когда мы оборачиваем DOM элемент в компонент, например, при создании систем дизайна.'],
    }
  ]
}